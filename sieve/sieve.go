package sieve

type Sieve struct {
	bits []uint32

	current_byte int
	current_bit  int

	N int64
}

var mask_get [32]uint32
var mask_mark [32]uint32

func init() {

	mask_get = [32]uint32{
		0b00000000000000000000000000000001,
		0b00000000000000000000000000000010,
		0b00000000000000000000000000000100,
		0b00000000000000000000000000001000,
		0b00000000000000000000000000010000,
		0b00000000000000000000000000100000,
		0b00000000000000000000000001000000,
		0b00000000000000000000000010000000,
		0b00000000000000000000000100000000,
		0b00000000000000000000001000000000,
		0b00000000000000000000010000000000,
		0b00000000000000000000100000000000,
		0b00000000000000000001000000000000,
		0b00000000000000000010000000000000,
		0b00000000000000000100000000000000,
		0b00000000000000001000000000000000,
		0b00000000000000010000000000000000,
		0b00000000000000100000000000000000,
		0b00000000000001000000000000000000,
		0b00000000000010000000000000000000,
		0b00000000000100000000000000000000,
		0b00000000001000000000000000000000,
		0b00000000010000000000000000000000,
		0b00000000100000000000000000000000,
		0b00000001000000000000000000000000,
		0b00000010000000000000000000000000,
		0b00000100000000000000000000000000,
		0b00001000000000000000000000000000,
		0b00010000000000000000000000000000,
		0b00100000000000000000000000000000,
		0b01000000000000000000000000000000,
		0b10000000000000000000000000000000,
	}

	mask_mark = [32]uint32{
		0b11111111111111111111111111111110,
		0b11111111111111111111111111111101,
		0b11111111111111111111111111111011,
		0b11111111111111111111111111110111,
		0b11111111111111111111111111101111,
		0b11111111111111111111111111011111,
		0b11111111111111111111111110111111,
		0b11111111111111111111111101111111,
		0b11111111111111111111111011111111,
		0b11111111111111111111110111111111,
		0b11111111111111111111101111111111,
		0b11111111111111111111011111111111,
		0b11111111111111111110111111111111,
		0b11111111111111111101111111111111,
		0b11111111111111111011111111111111,
		0b11111111111111110111111111111111,
		0b11111111111111101111111111111111,
		0b11111111111111011111111111111111,
		0b11111111111110111111111111111111,
		0b11111111111101111111111111111111,
		0b11111111111011111111111111111111,
		0b11111111110111111111111111111111,
		0b11111111101111111111111111111111,
		0b11111111011111111111111111111111,
		0b11111110111111111111111111111111,
		0b11111101111111111111111111111111,
		0b11111011111111111111111111111111,
		0b11110111111111111111111111111111,
		0b11101111111111111111111111111111,
		0b11011111111111111111111111111111,
		0b10111111111111111111111111111111,
		0b01111111111111111111111111111111,
	}
}

func (sv *Sieve) Begin() {
	sv.current_byte = 0
	sv.current_bit = 0
}

func (sv *Sieve) Next() {
	sv.current_bit++
	if sv.current_bit == 32 {
		sv.current_byte++
		sv.current_bit = 0
	}
}

// Initialize the sieve to store enough int64 numbers
func (sv *Sieve) Init(N int64) {
	sv.N = N
	required_size := N/(3*32) + 1
	sv.bits = make([]uint32, required_size)
	len_bits := len(sv.bits)

	//
	// initially, set all bits to 1 to tell that they are primes
	//
	for i := 0; i < len_bits; i++ {
		sv.bits[i] = 0b11111111111111111111111111111111
	}
}

// Retrieve current element.
func (sv *Sieve) Get() uint32 {
	return sv.bits[sv.current_byte] & mask_get[sv.current_bit]
}

// Mark position idx as non prime
func (sv *Sieve) Mark(n int64) {

	//
	// compact sieve for 2
	//
	//var ii int64 = (n - 3) / 2

	//
	// compact sieve for 2, 3
	//
	var ii int64 = (n - 5) / 3
	m := (n - 5) % 3
	if m == 2 {
		ii++
	} else if m != 0 {
		return // m==1 is a multiple of 3 , already remove > skip !
	}

	b := int(ii / 32)
	bi := int(ii % 32)

	sv.bits[b] = sv.bits[b] & mask_mark[bi]
}

func flip24(d int64) int64 {
	if d == 4 {
		return 2
	}
	return 4
}

// Can be better!
func (sv *Sieve) Count() int64 {
	var prime int64 = 0
	var count int64 = 2
	var d int64 = 4
	sv.Begin()
	for prime = 5; prime <= sv.N; prime += d {
		if sv.Get() != 0 {
			count++
		}
		sv.Next()
		d = flip24(d)
	}
	return count
}

// func (sv *Sieve) Compare(svOther *Sieve) {
// 	var prime int64
// 	var d int64 = 4

// 	sv.Begin()
// 	svOther.Begin()

// 	for prime = 5; prime <= sv.N; prime += d {
// 		if (sv.Get() != 0) != (svOther.Get() != 0) {
// 			fmt.Println(prime)
// 		}
// 		sv.Next()
// 		svOther.Next()
// 		d = flip24(d)
// 	}
// }
